# **Lecture 25: 상호 배타적 집합**

by | 혜민

pub date | 2020.11.07.Sat

### **상호 배타적 집합**
: 공통 원소가 없는 부분 집합!들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료 구조  
-> `유니온-파인드 자료 구조`

#### 유니온 파인드 자료 구조에 필요한 세 가지 연산
1. 초기화 : n개의 원소가 각각의 집합에 포함되도록 초기화
2. 합치기(union) : 두 원소 a, b가 주어질 떄 이들이 속한 두 집합을 하나로 합침
3. 찾기(find) : 어떤 원소 a가 주어질 때 이 원소가 속한 집합 반환

#### 배열로 상호 배타적 집합 표현
1차원 배열을 이용하여 표현할 수 있다!
```c++
belongsTo[i] 
// i번 원소가 속하는 집합의 번호
```
해당 배열을 각기 다른 숫자 1..n으로 초기화하면 요소별로 각자 다른 집합에 속함을 구현한 것  
-> 찾기 연산을 상수 시간(O(1))에 구현  
-> 합치기 연산의 경우 모든 원소를 순회하며 한쪽 집합에 속한 원소들을 다른 쪽 집합으로 옮겨야 하므로 O(N)의 시간 복잡도



합치기 연산을 빠르게 하기 위해!!!
#### 트리를 이용한 상호 배타적 집합의 표현
코드 25.1 
```c++
// 트리를 이용해 상호 배제적 집합을 구현한다.
struct NaiveDisjointSet {
	vector<int> parent;

	// : (콜론)을 쓰는 이유는 초기화 리스트를 사용했기 때문
	// 초기화 리스트 : 생성자가 호출될 때 객체의 생성과 초기화가 한 번에 이루어짐
	// 생성자 함수 내에서 초기화 : 객체가 생성되어, default생성자로 초기화된 상태에서 다시 한 번 할당
	NaiveDisjointSet(int n) : parent(n) {
		for(int i = 0; i < n; i++)
			parent[i] = i;
	}

	// u 가 속한 트리의 루트의 번호를 반환한다
	int find(int u) const {
		if(u == parent[u]) return u;
		return find(parent[u]);
	}

	// u 가 속한 트리와 v 가 속한 트리를 합친다
	void merge(int u, int v) {
		u = find(u);
		v = find(v);
		// u 와 v 가 이미 같은 트리에 속하더라도 상관 없다
		parent[u] = v;
	}
};
```
