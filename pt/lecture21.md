## Lecture 21: 트리의 구현과 순회
by | 지은  
pub date | 2020.10.17.Sat

### 도입
**트리** | 계층적 구조를 갖는 자료들을 표현하기 위한 자료 구조
**트리의 구성 요소**
- `노드(node)`들을 `간선(edge)`으로 서로 연결
- `노드(node)` 간에는 상/하위 관계 
- `부모(parent) 노드`, `자식(child) 노드`, `형제(sibling) 노드`

- `선조(ancestor)`와 `자손(descendant)`

👨‍🏫 여러 개의 자식 보유 가능, 부모는 딱 한 개만!
👨‍🏫 다른 모든 노드들은 자손으로 갖는 노드 👉 **뿌리** 또는 **루트(root)**
👨‍🏫 자식이 하나도 없는 노드들 👉 **잎 노드** 또는 **리프(leaf)**

**트리와 노드의 속성**
- (노드의) 깊이(depth): 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
- (트리의) 높이(height): 트리에서 가장 깊숙이 있는 노드의 깊이

**트리의 재귀적 속성**
- 한 노드와 그의 자손들을 모두 모으면 또 다른 하나의 트리 완성
👉 **노드 t**를 루트로 하는 **서브트리(subtree)**
- 재귀 호출 사용 가능

**트리의 표현**
- 각 노드를 하나의 `구조체(struct)/객체(object)`로 표현하고, 이들을 서로의 포인터로 연결
- 각 노드들은 자신의 부모와 모든 자손들에 대한 포인터 보유 

```java
  
  struct TreeNode {
    string label;
    TreeNode* parent;
    vector<TreeNode*> children;
  }

```


### 트리의 순회
트리의 루트가 주어질 때 루트를 방문한 뒤 각 서브트리를 재귀적으로 방문

```java

  void printLables(TreeNode* root) {
    cout << root->label << endl;
    
    // 각 자식 노드를 루트로 하는 서브트리들에 대하여 재귀 호출
    for (int i=0; i<root->children.size(); ++i) {
      printLabels(root->children[i]);
    }
  }

```


트리의 높이 구하기
1. 루트의 각 자식들을 루트로 하는 서브트리들의 높이를 각각 재귀 호출을 통해 계산
2. 전체 트리의 높이는 그중 최대치에 1을 더한 것

```java

  int height(TreeNode* root) {
    int h = 0;
    for (int i=0; i<root->children.size(); ++i) {
      h = max(h, 1+ height(root->children[i]));
    }
    return h;
  }

```

👉 `O(n)` 시간 소요(?)

### 문제: 트리 순회 순서 변경 
이진 트리(binary tree): 모든 노드에 왼/오 최대 두 개의 자손이 있는 트리
- 전위 순회(preorder)
- 중위 순회(inorder)
- 후위 순회(postorder)
[code 21.3]()

### 문제: 요새
성벽들 간의 포함 관계를 트리로 구현
1. 성벽으로 구분된 요새 내부의 각 '구역'에 번호 매기기
2. 한 구역이 다른 구역을 직접 포함할 경우 두 구역을 연결하여 포함관계를 트리로 표현
➡️ 성벽 넘기 = 간선을 따라 다른 노드로 옮겨가는 것
👉 즉, 트리에서 가장 멀리 떨어진 두 노드를 찾는 문제

👨‍🏫 최장 경로 문제: 최장 경로의 양 끝 노드가 항상 루트 또는 잎 노드여야 함 
(내부 노드는 항상 두 개 이상의 간선과 연결되어 있기 때문에, 하나의 경로를 선택할 경우 다른 하나는 사용되지 않은 채 남기 때문)

1. 가장 긴 루트-잎 경로의 길이 (= 트리🌴의 높이) 
2. 가장 긴 잎-잎 경로의 길이 👉 각 서브트리의 높이를 계산한 뒤, 가장 높은 두 개의 서브트리를 선택 

