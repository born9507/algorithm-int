# ch23-24 - 백준 문제 풀이

by | 지은   
pub date | 2021.02.06.Sat

### 우선순위 큐와 힙  
- 이진 검색 트리 대신 힙(heap)을 이용, 가장 큰 원소 찾기  
- `O(logN)` 시간에 수행  

**힙의 정의와 구현**  
- 힙의 대소 관계 규칙: 부모 노드가 가진 원소는 항상 자식 노드가 가진 원소 이상 (최대 힙)  
- 모양 규칙을 만족하는 힙의 높이는 `O(logN)`  

**배열을 이용한 힙의 구현**  
```c++
vector<int> heap;
```
힙의 원소들을 맨 윗 레벨부터, 왼쪽에서 오른쪽의 순서대로 저장  

**새 원소의 삽입**  
1. 모양 규칙 맞추기 - 새 노드가 트리의 어느 쪽에 생겨나야 하는지?  
2. 대소 관계 맞추기 - 마지막에 추가한 새 원소를 자신의 부모 노드가 가진 원소와 비교해 나가기
![img](baekjoon2324.assets/push_heap.jpg)  

**최대 원소 꺼내기**  
1. 마지막 노드로 루트를 덮어 씌우기  
2. 두 자식 중 더 큰 원소를 갖는 노드와 원소 교환 반복
![img](baekjoon2324.assets/pop_heap.jpg)
  
### 구간 트리  
- 일차원 배열의 특정 구간에 대한 문제  
- 주어진 배열의 구간들을 표현하는 이진 트리 만들기  
- 노드마다 해당 구간에 대한 계산 결과 저장 (전처리)
![img](baekjoon2324.assets/segment_tree.jpg)  

**구간 트리의 표현**  
- 이진 트리를 배열로 표현  

**구간 트리의 초기화**  
- 각 노드마다 해당 구간의 최소치 계산  

**구간 트리의 질의 처리**  
- 임의의 구간에서의 최소치  
`query(left, right, node, nodeLeft, nodeRight)`  
- `O(logN)` 소요

**구간 트리의 갱신**  
- 위치를 포함하는 구간들만 재계산  

### 펜윅 트리: 빠르고 간단한 구간 합  
- 구간 합 대신 부분 합만을 빠르게 계산하는 자료구조  
```
[i, j] 구간의 합은 sum[j]-sum[i-1]
``` 
![img](baekjoon2324.assets/fenwick.jpg)  
- 각 구간의 번호를 이진수로 표현      
