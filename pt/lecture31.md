## Lecture 31. 최소 스패닝 트리
by | 지은  
pub date | 2020.12.19.Sat

---

- 무향 그래프의 스패닝 트리: 원래 그래프의 정점 전부와 간선의 부분 집합으로 구성된 부분 그래프  
👩‍🏫 스패닝 트리에 포함된 간선들은 저점들을 트리 형태로 전부 연결  
- 최소 스패닝 트리 문제: 가중치 그래프의 스패닝 트리 중 가중치의 합이 가장 작은 트리 찾기  

**두 가지의 알고리즘**  
- 크루스칼 알고리즘
- 프림 알고리즘

---
### 크루스칼의 최소 스패닝 트리 알고리즘 
- 그래프의 모든 간선을 가중치의 오름차순으로 정렬한 뒤, 스패닝 트리에 하나씩 추가  
- 이때, 사이클이 생기는 간선은 제외  
- 모든 간선을 한 번씩 검사하고 난 뒤 종료  
→ 그래프의 모든 정점을 연결하고, 사이클이 없는 트리 완성  

**자료 구조의 선택**  
1. 간선의 목록을 얻어서 가중치 순서대로 정렬  
2. 위를 순회하며 스패닝 트리에 추가  
2-1. 이때 이미 추가한 간선들과 합쳐 사이클을 이루는지 여부 판단  

- 깊이 우선 탐색: 트리에 간선을 추가한 뒤, 트리를 깊이 우선 탐색하면서 역방향 간선이 있는지 확인  
→ 각 간선마다 한 번씩 깊이 우선 탐색, 시간 복잡도 `O(|E|^2)`  

👩‍🏫 상호 배타적 집합 자료 구조(유니온-파인드) 활용하기  
- 두 정점이 이미 같은 집합에 속해 있는지 확인
- 간선을 트리에 추가할 때는 이들이 포함된 두 집합을 합치기  

**크루스칼 알고리즘의 구현**  
: 시간 복잡도 `O(|E|log|E|)`
  
[code31.1](https://github.com/zigsong/algorithm-int/blob/jieun/jieun/lec_31-32/code31_1.cpp)

---

### 프림의 최소 스패닝 트리 알고리즘  
- 하나의 시작점으로 구성된 트리에 간선을 하나씩 추가하며 스패닝 트리가 될 때까지 키워 나감  
- 😮 선택된 간선들은 중간 과정에서도 항상 연결된 트리를 이룸  
- 스패닝 트리를 찾아낼 때까지 후보 간선들 중 가중치가 가장 작은 간선을 추가하는 과정 반복  

**프림 알고리즘의 구현**  
: 트리에 속하지 않은 각 정점에 대해, 트리와 이 정점을 연결하는 가장 짧은 간선에 대한 정보를 저장하고, 각 정점을 순회하면서 다음에 추가할 정점 찾기  
👩‍🏫 트리와 이 정점을 연결하는 간선의 최소 가중치를 저장하는 배열 `minWeight[]`를 유지  
😮 사용하는 간선의 다른 한쪽 끝 정점을 `parent[]`에 저장

[code31.2](https://github.com/zigsong/algorithm-int/blob/jieun/jieun/lec_31-32/code31_2.cpp)


**프림 알고리즘의 다른 구현**  
: 다익스트라 알고리즘에서처럼 우선순위 큐를 사용하는 방법  

---

### 문제: 근거리 네트워크    
🤔 건물 x,y좌표만 줘 놓고 연결은 건물 번호로 하는 건 무슨 경우?  
- 각 간선의 가중치를 두 건물 사이 거리로 하되, 이미 두 건물이 연결되어 있는 경우 가중치를 0으로  

